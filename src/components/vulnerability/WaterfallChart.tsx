
import React from 'react';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, Cell, ReferenceLine } from 'recharts';
import { PortfolioImpact } from '@/store/types';
import { formatCurrency } from '@/utils/formatters';

interface WaterfallChartProps {
  impact: PortfolioImpact;
  scenarioName: string;
}

export const WaterfallChart: React.FC<WaterfallChartProps> = ({ impact, scenarioName }) => {
  // Skip if we don't have valid impact data
  if (!impact || !impact.assetClassImpacts) return null;

  // Prepare data for the waterfall chart
  const waterfallData = [];
  
  // Add starting point (original total value)
  waterfallData.push({
    name: 'Original Value',
    value: impact.originalValue,
    isTotal: true,
    isPositive: false,
    isStartValue: true,
  });

  // Add each asset class impact - sort by impact (largest negative first, then positive)
  Object.entries(impact.assetClassImpacts)
    .sort((a, b) => a[1].absoluteChange - b[1].absoluteChange) // Sort by impact (negative to positive)
    .forEach(([assetClass, classImpact]) => {
      if (classImpact.absoluteChange !== 0) {
        waterfallData.push({
          name: assetClass,
          value: classImpact.absoluteChange,
          percentChange: classImpact.percentageChange,
          isPositive: classImpact.absoluteChange > 0,
          isNegative: classImpact.absoluteChange < 0,
        });
      }
    });

  // Add ending point (final total value)
  waterfallData.push({
    name: 'Projected Value',
    value: impact.impactedValue,
    isTotal: true,
    isEndValue: true,
  });

  // Calculate running values and positions for the waterfall chart
  let cumulativeValue = impact.originalValue;
  
  const chartData = waterfallData.map((entry, index) => {
    if (entry.isStartValue) {
      return {
        ...entry,
        displayValue: cumulativeValue,
        y: 0,
        height: cumulativeValue,
        fill: '#000000', // Black color for start
      };
    }
    
    if (entry.isEndValue) {
      return {
        ...entry,
        displayValue: cumulativeValue,
        y: 0,
        height: cumulativeValue,
        fill: '#000000', // Black color for end
      };
    }
    
    const startY = entry.isPositive ? cumulativeValue : cumulativeValue + entry.value;
    const height = Math.abs(entry.value);
    const fill = entry.isPositive ? '#1E8539' /* green */ : '#CE1126' /* red */;
    
    // Save the previous value before updating
    const previousValue = cumulativeValue;
    
    // Update the cumulative value
    cumulativeValue = cumulativeValue + entry.value;
    
    return {
      ...entry,
      previousValue,
      displayValue: cumulativeValue,
      y: startY,
      height: height,
      fill,
    };
  });

  // Calculate domain for y-axis to ensure proper scaling with some padding
  const minValue = Math.min(impact.originalValue, impact.impactedValue) * 0.85;
  const maxValue = Math.max(impact.originalValue, impact.impactedValue) * 1.15;

  // Custom tooltip for the waterfall chart
  const CustomTooltip = ({ active, payload, label }: any) => {
    if (!active || !payload || !payload.length) return null;
    
    const data = payload[0].payload;
    
    if (data.isTotal) {
      return (
        <div className="bg-white p-3 border rounded shadow-lg">
          <p className="font-semibold">{data.name}</p>
          <p>{formatCurrency(data.displayValue)}</p>
        </div>
      );
    }
    
    const sign = data.isPositive ? '+' : '';
    
    return (
      <div className="bg-white p-3 border rounded shadow-lg">
        <p className="font-semibold">{data.name}</p>
        <p>Change: <span className={data.isPositive ? 'text-green-500' : 'text-red-500'}>
          {sign}{formatCurrency(data.value)}
        </span> ({data.percentChange?.toFixed(2)}%)</p>
        <p>Running Total: {formatCurrency(data.displayValue)}</p>
      </div>
    );
  };

  return (
    <Card className="mt-6">
      <CardHeader>
        <CardTitle>P&L Breakdown: {scenarioName}</CardTitle>
        <CardDescription>
          Value change progression by asset class
        </CardDescription>
      </CardHeader>
      <CardContent>
        <div className="h-80 mt-2">
          <ResponsiveContainer width="100%" height="100%">
            <BarChart
              data={chartData}
              margin={{ top: 20, right: 30, left: 40, bottom: 30 }}
            >
              <CartesianGrid strokeDasharray="3 3" vertical={false} />
              <XAxis 
                dataKey="name" 
                axisLine={false}
                tickLine={false}
                tick={{ fontSize: 12, fill: '#6B7280' }}
                angle={-20}
                textAnchor="end"
                height={60}
              />
              <YAxis 
                axisLine={false}
                tickLine={false}
                tick={{ fontSize: 12, fill: '#6B7280' }}
                domain={[minValue, maxValue]}
                tickFormatter={(value) => {
                  return new Intl.NumberFormat('en-US', {
                    style: 'currency',
                    currency: 'USD',
                    notation: 'compact',
                    maximumFractionDigits: 1,
                  }).format(value);
                }}
              />
              <Tooltip content={<CustomTooltip />} />
              
              {/* Horizontal reference line at 0 */}
              <ReferenceLine y={0} stroke="#000000" strokeWidth={1} />

              {/* Horizontal connector lines between bars */}
              {chartData.map((entry, index) => {
                // Don't draw connector after the last entry
                if (index === chartData.length - 1) return null;
                
                const nextEntry = chartData[index + 1];
                const yValue = entry.isStartValue ? entry.displayValue : entry.displayValue;
                
                return (
                  <ReferenceLine 
                    key={`connector-${index}`}
                    y={yValue}
                    segment={[
                      { x: index, y: yValue },
                      { x: index + 1, y: yValue }
                    ]}
                    stroke="#999"
                    strokeWidth={1}
                    strokeDasharray="3 3"
                  />
                );
              })}

              {/* Actual bars */}
              <Bar 
                dataKey="height"
                minPointSize={5}
                isAnimationActive={true}
              >
                {chartData.map((entry, index) => (
                  <Cell 
                    key={`cell-${index}`}
                    fill={entry.fill}
                    y={entry.y}
                  />
                ))}
              </Bar>
            </BarChart>
          </ResponsiveContainer>
        </div>
      </CardContent>
    </Card>
  );
};
