
import React from 'react';
import { ChartContainer, ChartTooltip, ChartTooltipContent } from "@/components/ui/chart";
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, ReferenceLine, Tooltip, Legend, ResponsiveContainer, Cell } from 'recharts';
import { PortfolioImpact } from '@/store/types';
import { formatCurrency, scChartColors } from '@/utils/formatters';

interface WaterfallChartProps {
  impact: PortfolioImpact;
  scenarioName: string;
}

export const WaterfallChart: React.FC<WaterfallChartProps> = ({ impact, scenarioName }) => {
  // Skip if we don't have valid impact data
  if (!impact || !impact.assetClassImpacts) return null;

  // Prepare data for the waterfall chart
  const waterfallData = [];
  
  // Initialize the running total with the original value
  let runningTotal = impact.originalValue;
  
  // Add starting point (original total value)
  waterfallData.push({
    name: 'Original Value',
    value: runningTotal,
    displayValue: runningTotal,
    absoluteChange: 0,
    isTotal: true,
    isStartValue: true,
  });

  // Add each asset class impact - sort by impact (largest negative first, then positive)
  Object.entries(impact.assetClassImpacts)
    .sort((a, b) => a[1].absoluteChange - b[1].absoluteChange) // Sort by impact (negative to positive)
    .forEach(([assetClass, classImpact]) => {
      if (classImpact.absoluteChange !== 0) {
        // Calculate the new running total
        const newTotal = runningTotal + classImpact.absoluteChange;
        
        waterfallData.push({
          name: assetClass,
          value: classImpact.absoluteChange, // The change this asset class contributes
          runningValue: newTotal, // The value after this change
          absoluteChange: classImpact.absoluteChange,
          percentChange: classImpact.percentageChange,
          isPositive: classImpact.absoluteChange > 0,
          isNegative: classImpact.absoluteChange < 0,
        });
        
        // Update running total for next iteration
        runningTotal = newTotal;
      }
    });

  // Add ending point (final total value)
  waterfallData.push({
    name: 'Projected Value',
    value: impact.impactedValue,
    displayValue: impact.impactedValue,
    absoluteChange: 0,
    isTotal: true,
    isEndValue: true,
  });

  // Transform data for Recharts waterfall chart
  const chartData = waterfallData.map((entry, index, array) => {
    // For start and end values, we want to show the full bar from 0
    if (entry.isStartValue || entry.isEndValue) {
      return {
        ...entry,
        // For start and end bars, show full height from 0
        start: 0,
        end: entry.value,
        fill: '#000000', // Black color for totals
      };
    } 
    
    // For change bars, position them properly
    const previousTotal = array[index - 1].isStartValue 
      ? array[index - 1].value 
      : array[index - 1].runningValue;
    
    return {
      ...entry,
      // For change bars (increases or decreases)
      // If positive change, start at previous value, end at new total
      // If negative change, start at new total, end at previous value
      start: entry.isPositive ? previousTotal : entry.runningValue,
      end: entry.isPositive ? entry.runningValue : previousTotal,
      fill: entry.isPositive ? scChartColors.secondary : scChartColors.tertiary,
    };
  });

  // Custom tooltip for the waterfall chart
  const CustomTooltip = ({ active, payload, label }: any) => {
    if (!active || !payload || !payload.length) return null;
    
    const data = payload[0].payload;
    
    if (data.isTotal) {
      return (
        <div className="bg-white p-3 border rounded shadow-lg">
          <p className="font-semibold">{data.name}</p>
          <p>{formatCurrency(data.value)}</p>
        </div>
      );
    }
    
    const sign = data.isPositive ? '+' : '';
    
    return (
      <div className="bg-white p-3 border rounded shadow-lg">
        <p className="font-semibold">{data.name}</p>
        <p>Change: <span className={data.isPositive ? 'text-green-500' : 'text-red-500'}>
          {sign}{formatCurrency(data.absoluteChange)}
        </span> ({data.percentChange.toFixed(2)}%)</p>
        <p>After: {formatCurrency(data.runningValue)}</p>
      </div>
    );
  };

  // Calculate domain for y-axis to ensure proper scaling with some padding
  const minValue = Math.min(impact.originalValue, impact.impactedValue) * 0.9;
  const maxValue = Math.max(impact.originalValue, impact.impactedValue) * 1.1;

  return (
    <Card className="mt-6">
      <CardHeader>
        <CardTitle>P&L Breakdown: {scenarioName}</CardTitle>
        <CardDescription>
          Value change progression by asset class
        </CardDescription>
      </CardHeader>
      <CardContent>
        <div className="h-80 mt-2">
          <ResponsiveContainer width="100%" height="100%">
            <BarChart
              data={chartData}
              margin={{ top: 20, right: 30, left: 40, bottom: 30 }}
            >
              <CartesianGrid strokeDasharray="3 3" vertical={false} />
              <XAxis 
                dataKey="name" 
                axisLine={false}
                tickLine={false}
                tick={{ fontSize: 12, fill: '#6B7280' }}
                angle={-20}
                textAnchor="end"
                height={60}
              />
              <YAxis 
                axisLine={false}
                tickLine={false}
                tick={{ fontSize: 12, fill: '#6B7280' }}
                domain={[minValue, maxValue]}
                tickFormatter={(value) => {
                  return new Intl.NumberFormat('en-US', {
                    style: 'currency',
                    currency: 'USD',
                    notation: 'compact',
                    maximumFractionDigits: 1,
                  }).format(value);
                }}
              />
              <Tooltip content={<CustomTooltip />} />
              
              {/* Reference lines connecting the segments */}
              {chartData.map((entry, index) => {
                // Don't draw a reference line for the first entry
                if (index === 0) return null;
                
                const previousEntry = chartData[index - 1];
                const connectValue = previousEntry.isStartValue 
                  ? previousEntry.value 
                  : previousEntry.runningValue;
                
                return (
                  <ReferenceLine 
                    key={`ref-line-${index}`}
                    y={connectValue}
                    segment={[
                      { x: index - 1, y: connectValue },
                      { x: index, y: connectValue }
                    ]}
                    stroke="#777777"
                    strokeWidth={1}
                    isFront={false}
                  />
                );
              })}
              
              {/* Base Bar Component for Waterfall*/}
              <Bar 
                dataKey="end" 
                stackId="a"
                fill="#8884d8"
              >
                {chartData.map((entry, index) => (
                  <Cell 
                    key={`cell-${index}`}
                    fill={entry.fill}
                  />
                ))}
              </Bar>
              
              {/* Invisible bar to create the waterfall effect */}
              <Bar 
                dataKey="start" 
                stackId="a"
                fill="transparent" 
              />
            </BarChart>
          </ResponsiveContainer>
        </div>
      </CardContent>
    </Card>
  );
};
