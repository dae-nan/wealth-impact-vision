
import React from 'react';
import { ChartContainer, ChartTooltip, ChartTooltipContent } from "@/components/ui/chart";
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, ReferenceLine, Tooltip, Legend, ResponsiveContainer, Cell } from 'recharts';
import { PortfolioImpact } from '@/store/types';
import { formatCurrency, scChartColors } from '@/utils/formatters';

interface WaterfallChartProps {
  impact: PortfolioImpact;
  scenarioName: string;
}

export const WaterfallChart: React.FC<WaterfallChartProps> = ({ impact, scenarioName }) => {
  // Skip if we don't have valid impact data
  if (!impact || !impact.assetClassImpacts) return null;

  // Prepare data for the waterfall chart
  const waterfallData = [];
  
  // Initialize the running total with the original value
  let runningTotal = impact.originalValue;
  
  // Add starting point (original total value)
  waterfallData.push({
    name: 'Original Value',
    value: 0, // The change from this bar is 0
    displayValue: impact.originalValue, // What to show in tooltip
    runningTotal: runningTotal, // Current value at this point
    isTotal: true,
    isStartValue: true,
  });

  // Add each asset class impact - sort by impact (largest negative first, then positive)
  Object.entries(impact.assetClassImpacts)
    .sort((a, b) => a[1].absoluteChange - b[1].absoluteChange) // Sort by impact (negative to positive)
    .forEach(([assetClass, classImpact]) => {
      if (classImpact.absoluteChange !== 0) {
        // Update running total
        runningTotal += classImpact.absoluteChange;
        
        waterfallData.push({
          name: assetClass,
          value: classImpact.absoluteChange, // The change this asset class contributes
          displayValue: classImpact.absoluteChange, // What to show in tooltip
          runningTotal: runningTotal, // Current value at this point
          isPositive: classImpact.absoluteChange > 0,
          isNegative: classImpact.absoluteChange < 0,
          originalValue: classImpact.originalValue,
          impactedValue: classImpact.impactedValue,
          percentChange: classImpact.percentageChange,
        });
      }
    });

  // Add ending point (new total value) - but as a change from the previous running total
  // Note: We don't actually change runningTotal here since it should already be equal to impact.impactedValue
  waterfallData.push({
    name: 'Projected Value',
    value: 0, // The change from this bar is 0
    displayValue: impact.impactedValue, // What to show in tooltip
    runningTotal: runningTotal, // Should be equal to impactedValue
    isTotal: true,
    isEndValue: true,
  });

  // Create a custom data structure for the waterfall chart that Recharts can render properly
  const chartData = waterfallData.map((item, index) => ({
    ...item,
    // For the start node, we set the y-value at the bottom of the chart
    y0: item.isStartValue ? 0 : waterfallData[index - 1].runningTotal,
    // The height of the bar is the running total for that node
    y1: item.runningTotal,
    // For visualization, we need the offset value to place bars correctly
    offset: item.isStartValue ? item.runningTotal : 0,
    // Add a field specifically for the Bar component to use as dataKey
    barValue: item.isStartValue || item.isEndValue ? item.runningTotal : Math.abs(item.value),
  }));

  // Custom tooltip for the waterfall chart
  const CustomTooltip = ({ active, payload, label }: any) => {
    if (!active || !payload || !payload.length) return null;
    
    const data = payload[0].payload;
    
    if (data.isTotal) {
      return (
        <div className="bg-white p-3 border rounded shadow-lg">
          <p className="font-semibold">{data.name}</p>
          <p>{formatCurrency(data.runningTotal)}</p>
        </div>
      );
    }
    
    return (
      <div className="bg-white p-3 border rounded shadow-lg">
        <p className="font-semibold">{data.name}</p>
        <p>Change: <span className={data.isPositive ? 'text-green-500' : 'text-red-500'}>
          {data.isPositive ? '+' : ''}{formatCurrency(data.displayValue)}
        </span> ({data.percentChange.toFixed(2)}%)</p>
        <p>Running Total: {formatCurrency(data.runningTotal)}</p>
      </div>
    );
  };

  return (
    <Card className="mt-6">
      <CardHeader>
        <CardTitle>P&L Breakdown: {scenarioName}</CardTitle>
        <CardDescription>
          Value change progression by asset class
        </CardDescription>
      </CardHeader>
      <CardContent>
        <div className="h-80 mt-2">
          <ResponsiveContainer width="100%" height="100%">
            <BarChart
              data={chartData}
              margin={{ top: 20, right: 30, left: 40, bottom: 30 }}
            >
              <CartesianGrid strokeDasharray="3 3" vertical={false} />
              <XAxis 
                dataKey="name" 
                axisLine={false}
                tickLine={false}
                tick={{ fontSize: 12, fill: '#6B7280' }}
                angle={-20}
                textAnchor="end"
                height={60}
              />
              <YAxis 
                axisLine={false}
                tickLine={false}
                tick={{ fontSize: 12, fill: '#6B7280' }}
                tickFormatter={(value) => {
                  return new Intl.NumberFormat('en-US', {
                    style: 'currency',
                    currency: 'USD',
                    notation: 'compact',
                    maximumFractionDigits: 1,
                  }).format(value);
                }}
              />
              <Tooltip content={<CustomTooltip />} />
              <Legend />
              <ReferenceLine 
                y={impact.originalValue} 
                stroke="#000" 
                strokeDasharray="3 3"
                label={{ 
                  value: "Original Value", 
                  position: "insideBottomRight",
                  fill: "#6B7280",
                  fontSize: 12
                }} 
              />
              <Bar 
                dataKey="barValue"
                stackId="waterfall"
                fill={scChartColors.primary}
                // Removed incorrect y0ActionId and y1ActionId properties
              >
                {/* Use Cell components to color each bar individually */}
                {chartData.map((entry, index) => {
                  let fillColor = scChartColors.primary;
                  
                  if (entry.isStartValue || entry.isEndValue) {
                    fillColor = "#000000"; // Black for original and projected value
                  } else if (entry.isPositive) {
                    fillColor = scChartColors.secondary; // Green for positive values
                  } else if (entry.isNegative) {
                    fillColor = scChartColors.tertiary; // Red for negative values
                  }
                  
                  return <Cell key={`cell-${index}`} fill={fillColor} />;
                })}
              </Bar>
            </BarChart>
          </ResponsiveContainer>
        </div>
      </CardContent>
    </Card>
  );
};
