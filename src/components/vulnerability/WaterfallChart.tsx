
import React from 'react';
import { ChartContainer, ChartTooltip, ChartTooltipContent } from "@/components/ui/chart";
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, ReferenceLine, Tooltip, Legend, ResponsiveContainer, Cell } from 'recharts';
import { PortfolioImpact } from '@/store/types';
import { formatCurrency, scChartColors } from '@/utils/formatters';

interface WaterfallChartProps {
  impact: PortfolioImpact;
  scenarioName: string;
}

export const WaterfallChart: React.FC<WaterfallChartProps> = ({ impact, scenarioName }) => {
  // Skip if we don't have valid impact data
  if (!impact || !impact.assetClassImpacts) return null;

  // Prepare data for the waterfall chart
  const waterfallData = [];

  // Add starting point (original total value)
  waterfallData.push({
    name: 'Original Value',
    value: impact.originalValue,
    total: impact.originalValue,
    isTotal: true,
    isStartValue: true,
  });

  // Add each asset class impact
  Object.entries(impact.assetClassImpacts)
    .sort((a, b) => b[1].absoluteChange - a[1].absoluteChange) // Sort by impact (largest first)
    .forEach(([assetClass, classImpact]) => {
      if (classImpact.absoluteChange !== 0) {
        waterfallData.push({
          name: assetClass,
          value: classImpact.absoluteChange,
          total: 0, // Will be calculated in the chart
          isPositive: classImpact.absoluteChange > 0,
          isNegative: classImpact.absoluteChange < 0,
          originalValue: classImpact.originalValue,
          impactedValue: classImpact.impactedValue,
          percentChange: classImpact.percentageChange,
        });
      }
    });

  // Add ending point (new total value)
  waterfallData.push({
    name: 'Projected Value',
    value: impact.impactedValue,
    total: impact.impactedValue,
    isTotal: true,
    isEndValue: true,
  });

  // Custom tooltip for the waterfall chart
  const CustomTooltip = ({ active, payload, label }: any) => {
    if (!active || !payload || !payload.length) return null;
    
    const data = payload[0].payload;
    
    if (data.isTotal) {
      return (
        <div className="bg-white p-3 border rounded shadow-lg">
          <p className="font-semibold">{data.name}</p>
          <p>{formatCurrency(data.value)}</p>
        </div>
      );
    }
    
    return (
      <div className="bg-white p-3 border rounded shadow-lg">
        <p className="font-semibold">{data.name}</p>
        <p>Original: {formatCurrency(data.originalValue)}</p>
        <p>Change: <span className={data.isPositive ? 'text-green-500' : 'text-red-500'}>
          {data.isPositive ? '+' : ''}{formatCurrency(data.value)}
        </span> ({data.percentChange.toFixed(2)}%)</p>
        <p>New Value: {formatCurrency(data.impactedValue)}</p>
      </div>
    );
  };

  return (
    <Card className="mt-6">
      <CardHeader>
        <CardTitle>P&L Breakdown: {scenarioName}</CardTitle>
        <CardDescription>
          Value change breakdown by asset class
        </CardDescription>
      </CardHeader>
      <CardContent>
        <div className="h-80 mt-2">
          <ResponsiveContainer width="100%" height="100%">
            <BarChart
              data={waterfallData}
              margin={{ top: 20, right: 30, left: 40, bottom: 30 }}
            >
              <CartesianGrid strokeDasharray="3 3" vertical={false} />
              <XAxis 
                dataKey="name" 
                axisLine={false}
                tickLine={false}
                tick={{ fontSize: 12, fill: '#6B7280' }}
                angle={-20}
                textAnchor="end"
                height={60}
              />
              <YAxis 
                axisLine={false}
                tickLine={false}
                tick={{ fontSize: 12, fill: '#6B7280' }}
                tickFormatter={(value) => {
                  return new Intl.NumberFormat('en-US', {
                    style: 'currency',
                    currency: 'USD',
                    notation: 'compact',
                    maximumFractionDigits: 1,
                  }).format(value);
                }}
              />
              <Tooltip content={<CustomTooltip />} />
              <Legend />
              <ReferenceLine y={0} stroke="#000" />
              <Bar 
                dataKey="value" 
                fill={scChartColors.primary} // Set a default fill color
              >
                {/* Use Cell components to color each bar individually */}
                {waterfallData.map((entry, index) => {
                  let fillColor = scChartColors.primary;
                  
                  if (entry.isStartValue) {
                    fillColor = "#000000"; // Black for original value
                  } else if (entry.isEndValue) {
                    fillColor = "#000000"; // Black for projected value
                  } else if (entry.isPositive) {
                    fillColor = scChartColors.secondary; // Green for positive values
                  } else if (entry.isNegative) {
                    fillColor = scChartColors.tertiary; // Red for negative values
                  }
                  
                  return <Cell key={`cell-${index}`} fill={fillColor} />;
                })}
              </Bar>
            </BarChart>
          </ResponsiveContainer>
        </div>
      </CardContent>
    </Card>
  );
};
