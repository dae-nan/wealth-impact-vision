
import { useState } from 'react';
import { usePortfolioStore } from '@/store/portfolioStore';
import { SAMPLE_VULNERABILITY_SCORES } from '@/utils/sampleVulnerabilityData';

export const useVulnerabilityComparison = () => {
  const { holdingsData, scenarios, calculateImpactForScenario } = usePortfolioStore();
  const [showComparison, setShowComparison] = useState(false);
  const [expandedScenario, setExpandedScenario] = useState<string | null>(null);
  
  const handleToggleComparison = () => {
    setShowComparison(!showComparison);
  };
  
  const handleExpandScenario = (scenarioId: string) => {
    if (expandedScenario === scenarioId) {
      setExpandedScenario(null);
    } else {
      setExpandedScenario(scenarioId);
    }
  };
  
  const calculateVulnerabilityScores = () => {
    if (!scenarios || !calculateImpactForScenario) {
      return [];
    }
    
    // For each scenario, calculate or retrieve the vulnerability score
    return scenarios.map(scenario => {
      const impact = calculateImpactForScenario(scenario.id);
      
      return {
        id: scenario.id,
        name: scenario.name,
        impact: impact,
        vulnerabilityScore: impact?.vulnerabilityScore || 0
      };
    }).sort((a, b) => b.vulnerabilityScore - a.vulnerabilityScore); // Sort by vulnerability score (highest first)
  };
  
  const prepareComparisonData = () => {
    if (!holdingsData) {
      return {};
    }
    
    const scenarioImpacts = calculateVulnerabilityScores();
    const comparisonData: Record<string, Record<string, number>> = {};
    
    // Add sample data
    Object.entries(SAMPLE_VULNERABILITY_SCORES || {}).forEach(([individual, scores]) => {
      // Only add if it's not the current portfolio
      if (holdingsData?.individualName !== individual) {
        comparisonData[individual] = scores;
      }
    });
    
    // Add current portfolio if we have calculated impacts
    comparisonData[holdingsData.individualName] = {};
    scenarioImpacts.forEach(scenario => {
      if (scenario.impact) {
        comparisonData[holdingsData.individualName][scenario.id] = scenario.vulnerabilityScore;
      }
    });
    
    return comparisonData;
  };
  
  // Get all unique asset classes across all scenario impacts
  const getAllAssetClasses = () => {
    const allAssetClasses = new Set<string>();
    const scenarioImpacts = calculateVulnerabilityScores();
    
    scenarioImpacts.forEach(scenario => {
      const impact = scenario.impact;
      if (impact?.assetClassImpacts) {
        Object.keys(impact.assetClassImpacts).forEach(assetClass => {
          allAssetClasses.add(assetClass);
        });
      }
    });
    
    return allAssetClasses;
  };
  
  return {
    holdingsData,
    scenarios,
    showComparison,
    expandedScenario,
    handleToggleComparison,
    handleExpandScenario,
    calculateVulnerabilityScores,
    prepareComparisonData,
    getAllAssetClasses
  };
};
